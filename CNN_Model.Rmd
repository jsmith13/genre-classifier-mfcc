---
title: "CNN Model"
author: "Jake Smith"
date: "7/12/2019"
---

Fit a rough convolutional neural network.

The training/validation set components X.train, Y.train, X.validation, and Y.validation are generated by "training_set_preparation.Rmd".

```{r setup, include=FALSE}
require(keras)
require(foreach)
require(dplyr)
```

Each observation is currently in a completely linear (vector) format with the following hierarchy.
The naming scheme is: MFCC.v[octave].[timestamp].[region]

- region (start, mid, end)
  - timestamp (1:998)
    - octave (1:12)

We will reshape the dataset into an array with dimensions [observations(n), region (3), timestamp (998), octave(12)].

```{r}
## reshape the train X matrix into the desired hierarchy
# loop through lines in matrix X.train
descriptors.df <- foreach(i = 1:dim(X.train)[1], .combine = rbind) %do% {
  # bind the descriptors into a dataframe with observation, region, timestamp, and octave encoded as variables
  descriptors.df <- cbind(expand.grid(i, 1:12, 1:998, c("start", "mid", "end")), X.train[i, ])
}

# add column names
colnames(descriptors.df) <- c("observation", "octave", "timepoint", "region", "value")

# reorder the dataframe according to the target hierarchy
# observation > region > timestamp > octave
descriptors.df <- arrange(descriptors.df, observation, region, timepoint, octave)

# build an array from the newly ordered dataframe
X.train <- array(descriptors.df$value, c(dim(X.train)[1], 3, 998, 12))


## repeat for the validation X matrix
descriptors.df <- foreach(i = 1:dim(X.validation)[1], .combine = rbind) %do% {
  # bind the descriptors into a dataframe with observation, region, timestamp, and octave encoded as variables
  descriptors.df <- cbind(expand.grid(i, 1:12, 1:998, c("start", "mid", "end")), X.validation[i, ])
}

# add column names
colnames(descriptors.df) <- c("observation", "octave", "timepoint", "region", "value")

# reorder the dataframe according to the target hierarchy
# observation > region > timestamp > octave
descriptors.df <- arrange(descriptors.df, observation, region, timepoint, octave)

# build an array from the newly ordered dataframe
X.validation <- array(descriptors.df$value, c(dim(X.validation)[1], 3, 998, 12))


# remove extraneous table
rm(descriptors.df)
```

We will try two approaches.
1) 1D convolution on the temporal domain.
2) 2D convolution on the temporal and frequency domains.

In each case, we will treat the three regions independently during the convolution layers, then aggregate for the fully connected classifier. The general architecture for our network will be:

- input
[n, 3, 998, 12]

- slice on region
3 x [batch, 1, 998, 12]

- in triplicate -
  convolution layers

- merge on region
[batch, 3, x, y]

- flatten layer
[batch, 3 * x * y]

- fully connected layer
[batch, 1000?]

- dropout layer

- fully connected layer
[batch, 1000?]

-dropout layer

- output layer
[batch, 12]



We will start by fitting an even simpler test network on just one of the regions, convolving the temporal domain.

```{r}
# define the model
model <- keras_model_sequential()
model %>%
  # lambda function layer to select the first region
  layer_lambda(function(x) {x[, 1, , ]}, input_shape = dim(X.train)[2:4]) %>%
  # convolution layer 1
  layer_conv_1d(filters = 100, kernel_size = 10, activation = "relu") %>%
  # max pooling layer 1
  layer_max_pooling_1d(pool_size = 3) %>%
  # convoution layer 2
  layer_conv_1d(filters = 50, kernel_size = 10, activation = "relu") %>%
  # max pooling layer 2
  layer_max_pooling_1d(pool_size = 2) %>%
  # flatten layer
  layer_flatten() %>%
  # fully connected layer 1
  layer_dense(500, activation = "relu") %>%
  # dropout layer 1
  layer_dropout(rate = 0.5) %>%
  # fully connected layer 2
  layer_dense(500, activation = "relu") %>%
  # dropout layer 2
  layer_dropout(rate = 0.5) %>%
  # output layer
  layer_dense(dim(Y.train)[2], activation = "softmax")
  
  # compile the model
  compile(model, loss = "categorical_crossentropy", optimizer = optimizer_rmsprop(), metrics = "accuracy")
  
  # fit the model
  fit(model, x = X.train, y = Y.train, epochs = 10, batch_size = 100, validation_data = list(X.validation, Y.validation), verbose = 1)
```


